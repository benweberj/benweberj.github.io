{"ast":null,"code":"export default function sketch(p) {\n  let canvas;\n\n  p.setup = () => {\n    canvas = p.createCanvas(p.windowWidth, p.windowHeight);\n    p.background('#0d1e35');\n  };\n\n  p.draw = () => {\n    p.clear();\n    p.background('#0d1e35');\n  };\n\n  p.myCustomRedrawAccordingToNewPropsHandler = newProps => {\n    if (canvas) {\n      p.fill(newProps.color);\n    }\n  };\n} // export default function sketch(p) {\n//   let canvas\n//   let nodes = []\n//   let maxDist = 200\n//   let nodeCount = 50\n//   p.setup = () => {\n//     canvas = p.createCanvas(p.windowWidth, p.windowHeight)\n//     p.background('#0d1e35')\n//     for (let i = 0; i < nodeCount; i++) {\n//       nodes.push(new Node(p, p.createVector(p.random(p.width), p.random(p.height)), maxDist))\n//     }\n//   }\n//   p.draw = () => {\n//     p.clear()\n//     p.background('#0d1e35')\n//     nodes.forEach(node => {\n//       node.update()\n//       let nearbyNodes = []\n//       nodes.forEach(other => {\n//         if (other !== node && node.pos.dist(other.pos) <= maxDist) {\n//           nearbyNodes.push(other)\n//         }\n//       })\n//       node.neighbors = nearbyNodes\n//       let mouse = p.createVector(p.mouseX, p.mouseY)\n//       // if (mouse.dist(node.pos) <= maxDist) {\n//         let dirToMouse = mouse.sub(node.pos)\n//         let vector = dirToMouse.mult(4 / Math.pow(dirToMouse.mag(), 2))\n//         node.vel.add(vector)\n//       // }\n//     })\n//   }\n//   p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n//     if (canvas) {\n//       p.fill(newProps.color)\n//     }\n//   }\n// }\n// class Node {\n//   constructor(p, origin, maxDist) {\n//     this.p = p\n//     this.maxDist = maxDist\n//     this.neighbors = []\n//     this.r = p.random(3, 10)\n//     this.rate = p.random(.5, 3)\n//     this.respawn()\n//     this.pos = origin\n//   }\n//   respawn() {\n//     this.pos = this.p.createVector(this.p.random(this.p.width), this.p.random(-300, -50))\n//     this.vel = this.p.createVector(this.p.random(-this.rate, this.rate), this.p.random(this.rate))\n//   }\n//   update() {\n//     this.pos.add(this.vel)\n//     this.interract(this.neighbors)\n//     // draw\n//     this.p.stroke('#fff')\n//     this.p.strokeWeight(this.r)\n//     this.p.point(this.pos.x, this.pos.y)\n//     this.checkBounds()\n//   }\n//   interract(neighbors) {\n//     neighbors.forEach(other => {\n//       this.p.strokeWeight(this.mapRange(this.pos.dist(other.pos), 0, this.maxDist+5, 1, 0))\n//       this.p.stroke('#fff')\n//       // this.p.line(this.pos.x, this.pos.y, other.pos.x, other.pos.y)\n//       let forceToThis = this.pos.copy().sub(other.pos).mult(.0001)\n//       other.vel.add(forceToThis)\n//     })\n//   }\n//   mapRange(num, inMin, inMax, outMin, outMax) {\n//     return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin\n//   }\n//   checkBounds() {\n//   }\n// }","map":{"version":3,"sources":["/Users/ben/Desktop/react-personalsite/src/particleMesh.js"],"names":["sketch","p","canvas","setup","createCanvas","windowWidth","windowHeight","background","draw","clear","myCustomRedrawAccordingToNewPropsHandler","newProps","fill","color"],"mappings":"AAAA,eAAe,SAASA,MAAT,CAAgBC,CAAhB,EAAmB;AAChC,MAAIC,MAAJ;;AAEAD,EAAAA,CAAC,CAACE,KAAF,GAAU,MAAM;AACdD,IAAAA,MAAM,GAAGD,CAAC,CAACG,YAAF,CAAeH,CAAC,CAACI,WAAjB,EAA8BJ,CAAC,CAACK,YAAhC,CAAT;AACAL,IAAAA,CAAC,CAACM,UAAF,CAAa,SAAb;AACD,GAHD;;AAKAN,EAAAA,CAAC,CAACO,IAAF,GAAS,MAAM;AACbP,IAAAA,CAAC,CAACQ,KAAF;AACAR,IAAAA,CAAC,CAACM,UAAF,CAAa,SAAb;AACD,GAHD;;AAKAN,EAAAA,CAAC,CAACS,wCAAF,GAA8CC,QAAD,IAAc;AACzD,QAAIT,MAAJ,EAAY;AACVD,MAAAA,CAAC,CAACW,IAAF,CAAOD,QAAQ,CAACE,KAAhB;AACD;AACF,GAJD;AAKD,C,CAID;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA","sourcesContent":["export default function sketch(p) {\n  let canvas\n\n  p.setup = () => {\n    canvas = p.createCanvas(p.windowWidth, p.windowHeight)\n    p.background('#0d1e35')\n  }\n\n  p.draw = () => {\n    p.clear()\n    p.background('#0d1e35')\n  }\n\n  p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n    if (canvas) {\n      p.fill(newProps.color)\n    }\n  }\n}\n\n\n\n// export default function sketch(p) {\n//   let canvas\n//   let nodes = []\n//   let maxDist = 200\n//   let nodeCount = 50\n\n//   p.setup = () => {\n//     canvas = p.createCanvas(p.windowWidth, p.windowHeight)\n//     p.background('#0d1e35')\n\n//     for (let i = 0; i < nodeCount; i++) {\n//       nodes.push(new Node(p, p.createVector(p.random(p.width), p.random(p.height)), maxDist))\n//     }\n//   }\n\n//   p.draw = () => {\n//     p.clear()\n//     p.background('#0d1e35')\n//     nodes.forEach(node => {\n//       node.update()\n\n//       let nearbyNodes = []\n//       nodes.forEach(other => {\n//         if (other !== node && node.pos.dist(other.pos) <= maxDist) {\n//           nearbyNodes.push(other)\n//         }\n//       })\n//       node.neighbors = nearbyNodes\n\n//       let mouse = p.createVector(p.mouseX, p.mouseY)\n//       // if (mouse.dist(node.pos) <= maxDist) {\n//         let dirToMouse = mouse.sub(node.pos)\n//         let vector = dirToMouse.mult(4 / Math.pow(dirToMouse.mag(), 2))\n//         node.vel.add(vector)\n//       // }\n//     })\n//   }\n\n//   p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n//     if (canvas) {\n//       p.fill(newProps.color)\n//     }\n//   }\n// }\n\n// class Node {\n\n//   constructor(p, origin, maxDist) {\n//     this.p = p\n//     this.maxDist = maxDist\n//     this.neighbors = []\n//     this.r = p.random(3, 10)\n//     this.rate = p.random(.5, 3)\n//     this.respawn()\n//     this.pos = origin\n//   }\n\n//   respawn() {\n//     this.pos = this.p.createVector(this.p.random(this.p.width), this.p.random(-300, -50))\n//     this.vel = this.p.createVector(this.p.random(-this.rate, this.rate), this.p.random(this.rate))\n//   }\n\n//   update() {\n//     this.pos.add(this.vel)\n\n//     this.interract(this.neighbors)\n\n//     // draw\n//     this.p.stroke('#fff')\n//     this.p.strokeWeight(this.r)\n//     this.p.point(this.pos.x, this.pos.y)\n\n//     this.checkBounds()\n//   }\n\n//   interract(neighbors) {\n//     neighbors.forEach(other => {\n//       this.p.strokeWeight(this.mapRange(this.pos.dist(other.pos), 0, this.maxDist+5, 1, 0))\n//       this.p.stroke('#fff')\n//       // this.p.line(this.pos.x, this.pos.y, other.pos.x, other.pos.y)\n\n//       let forceToThis = this.pos.copy().sub(other.pos).mult(.0001)\n//       other.vel.add(forceToThis)\n//     })\n//   }\n\n//   mapRange(num, inMin, inMax, outMin, outMax) {\n//     return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin\n//   }\n\n//   checkBounds() {\n\n//   }\n// }"]},"metadata":{},"sourceType":"module"}