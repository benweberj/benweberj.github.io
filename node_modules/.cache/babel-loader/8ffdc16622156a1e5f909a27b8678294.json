{"ast":null,"code":"export default function sketch(p, poop) {\n  let canvas;\n  let grid;\n  let cellSize;\n  let bg;\n  let color;\n  let start;\n\n  p.setup = () => {\n    canvas = p.createCanvas(p.windowWidth * .8, p.windowHeight * .8); // these will be hardcoded until I fond a way to pass props to setup, or force a refresh\n    // bg = '#fff'\n    // color= '#111'\n    // start = false\n    // p.noStroke()\n    // p.background(bg)\n    // cellSize = p.width / 50\n    // canvas.position(0, 0)\n    // grid = new Grid(cellSize)\n  };\n\n  p.draw = () => {\n    p.background(0, 30); // if (start) {\n    //   p.background(bg)\n    //   grid.update()\n    // }\n  };\n\n  p.windowResized = () => p.resizeCanvas(p.windowWidth * .8, p.windowHeight * .8);\n\n  class Grid {\n    constructor(cellSize) {\n      this.cellSize = cellSize;\n      this.grid = [];\n\n      for (let x = 0; x < p.width; x += cellSize) {\n        let col = [];\n\n        for (let y = 0; y < p.height; y += cellSize) {\n          col.push(new Cell(p.createVector(x + cellSize / 2, y + cellSize / 2), cellSize));\n        }\n\n        this.grid.push(col);\n      }\n    }\n\n    update() {\n      this.grid.forEach(col => {\n        col.forEach(cell => {\n          cell.draw();\n        });\n      });\n    }\n\n  } // p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n  //   // if (canvas) {\n  //     bg = newProps.theme.base\n  //     color = newProps.theme.complement\n  //     start = true\n  //   // }\n  // }\n\n\n  class Cell {\n    constructor(pos, cellSize, color) {\n      this.pos = pos;\n      this.cellSize = cellSize;\n    }\n\n    draw() {\n      let mouse = p.createVector(p.mouseX, p.mouseY);\n      let mDist = mouse.dist(this.pos);\n      let scaledSize = this.cellSize * (5 / mDist);\n      if (scaledSize > this.cellSize / 4) scaledSize = cellSize / 4;\n      p.fill(color);\n      p.ellipse(this.pos.x, this.pos.y, scaledSize);\n    }\n\n  }\n}","map":{"version":3,"sources":["/Users/ben/Repos/react-personal-site/src/particleMesh.js"],"names":["sketch","p","poop","canvas","grid","cellSize","bg","color","start","setup","createCanvas","windowWidth","windowHeight","draw","background","windowResized","resizeCanvas","Grid","constructor","x","width","col","y","height","push","Cell","createVector","update","forEach","cell","pos","mouse","mouseX","mouseY","mDist","dist","scaledSize","fill","ellipse"],"mappings":"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","sourcesContent":["export default function sketch(p, poop) {\n  let canvas  \n  let grid\n  let cellSize\n  let bg\n  let color\n  let start\n\n  p.setup = () => {\n    canvas = p.createCanvas(p.windowWidth * .8, p.windowHeight * .8)\n    \n    // these will be hardcoded until I fond a way to pass props to setup, or force a refresh\n    // bg = '#fff'\n    // color= '#111'\n    \n    // start = false\n    // p.noStroke()\n    // p.background(bg)\n    // cellSize = p.width / 50\n    // canvas.position(0, 0)\n    \n    // grid = new Grid(cellSize)\n  }\n\n  p.draw = () => {\n    p.background(0, 30)\n    // if (start) {\n    //   p.background(bg)\n    //   grid.update()\n    // }\n  }\n\n  p.windowResized = () => p.resizeCanvas(p.windowWidth * .8, p.windowHeight * .8)\n\n  class Grid {\n    constructor(cellSize) {\n      this.cellSize = cellSize\n      this.grid = []\n      for (let x = 0; x < p.width; x += cellSize) {\n        let col = []\n        for (let y = 0; y < p.height; y += cellSize) {\n          col.push(new Cell(p.createVector(x + cellSize/2, y + cellSize/2), cellSize))\n        }\n        this.grid.push(col)\n      }\n    }\n\n    update() {\n      this.grid.forEach(col => {\n        col.forEach(cell => {\n          cell.draw()\n        })\n      })\n    }\n  }\n\n  // p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n  //   // if (canvas) {\n  //     bg = newProps.theme.base\n  //     color = newProps.theme.complement\n  //     start = true\n  //   // }\n    \n  // }\n\n  class Cell {\n    constructor(pos, cellSize, color) {\n      this.pos = pos\n      this.cellSize = cellSize\n    }\n\n    draw() {\n      let mouse = p.createVector(p.mouseX, p.mouseY) \n      let mDist = mouse.dist(this.pos)\n      let scaledSize = this.cellSize * (5 / mDist)\n      \n      if (scaledSize > this.cellSize/4) scaledSize = cellSize/4\n      p.fill(color)\n      p.ellipse(this.pos.x, this.pos.y, scaledSize)\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}